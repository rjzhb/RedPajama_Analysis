/*
This is a code that can merge those results that generated by multi thread
The results are the groups that contains id and position of intersection of similar documents,
This code's job is to merge them and output the similar pairs
*/
#include <bits/stdc++.h>
#include "../src/util/io.h"
using namespace std;

const int K = 32;
const int c = 29;

inline bool judgeMinHashJaccard(const int & pos_1, const int & pos_2)
{
    if(pos_1 - c + 1 + pos_2 - c + 1<= K-c){
        return true;
    }
    return false;
}

int main() {
    
    const string root_dir = "/research/projects/zp128/RedPajama_Analysis/OverlapJoin";
    const string dataset = "intergrated";
    const string simP_dirpath = root_dir + "/similar_pairs/" + dataset + "_simPair_K" + to_string(K) + "_C" + to_string(c) + "/";

    // Read the idmap and simpair
    vector<int> idmap;
    const string idmap_file_path = simP_dirpath + "idmap.bin";
    loadBin2vec(idmap_file_path, idmap);

    // Merge the groups that generated by the threads
    const int MAXTHREAD = 128;
    vector < vector<pair<int,int>>> res_lists;
    for(int i = 0 ;i< MAXTHREAD;i++){
        vector < vector<pair<int,int>>> tmp_list;
        const string divided_simp_file_path = simP_dirpath + to_string(i)+".bin";
        readDividedList(divided_simp_file_path, tmp_list);
        res_lists.insert( res_lists.end(), tmp_list.begin(), tmp_list.end());
    }

   
    // Calculate the similar pairs and make sure no duplication
    vector<vector<int>> id_lists(idmap.size());
    for (int i = 0; i < res_lists.size(); i++) {
        for (int j = 0; j < res_lists[i].size(); j++)
            id_lists[res_lists[i][j].first].push_back(i);
    }

    // for(auto const group : res_lists){
    //     for(auto id:group ){
    //         cout<<id.first<<" ";
    //     }
        
    //     cout<<endl;
    // }
    
    cout << "Starting Calculating " <<endl;
    int n = idmap.size();
    unsigned long long candidate_num = 0LL;
    long long result_num  = 0;
    vector<pair<int,int> > sim_pairs;
    vector<int> results(n, -1);
    for (int i = n - 1; i >= 0; i--) {
        if (id_lists[i].empty())
            continue;
        for (int j = 0; j < id_lists[i].size(); j++) {
            auto last_cur_1 = res_lists[id_lists[i][j]].back().second;
            res_lists[id_lists[i][j]].pop_back();
            for (int k = 0; k < res_lists[id_lists[i][j]].size(); k++) {
                if (results[res_lists[id_lists[i][j]][k].first] != i) {
                    candidate_num++;
                    results[res_lists[id_lists[i][j]][k].first] = i;
                    auto last_cur_2 = res_lists[id_lists[i][j]][k].second;
                    if(judgeMinHashJaccard(last_cur_1, last_cur_2)){
                        int idd1 = i;
                        int idd2 = res_lists[id_lists[i][j]][k].first;
                        sim_pairs.emplace_back(idd1, idd2);
                        ++result_num;
                    }
                    // cout << idmap[i].first << " " << idmap[res_lists[id_lists[i][j]][k]].first << endl;
                }
            }
        }
    }
    cout << "Candidate Num: " << candidate_num << endl;
    cout << "Result Num: " << result_num << endl;

    // Output the similar pairs
    for (int i = 0; i < 5; i++) {
        printf("Similar pairs: %d %d\n", idmap[sim_pairs[i].first], idmap[sim_pairs[i].second]);
    }

    // the path of files that would be written
    const string simpair_file_path = simP_dirpath + "sim_pairs.bin";
    writeSimilarPair(simpair_file_path, sim_pairs);
}